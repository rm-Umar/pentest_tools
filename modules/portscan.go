package modules

import (
	"fmt"
	"net"
	"sync"
	"time"
)

var COMMON_PORTS = []uint16{
	7, 9, 13, 19, 21, 22, 23, 25, 26, 37, 53, 79, 80, 81, 82, 88, 100, 1030, 1041, 110, 111, 113,
	119, 144, 1755, 1801, 1900, 199, 255, 2717, 3000, 3001, 3128, 32768, 3389, 3986, 427, 444, 465,
	5060, 5101, 513, 514, 5190, 5357, 543, 544, 548, 5631, 5666, 5800, 587, 6000, 6001, 631, 646,
	7070, 8000, 8008, 8009, 8031, 8080, 8081, 8443, 873, 8888, 9090, 9100, 9300, 990, 993, 995, 9999,
	1024, 1025, 1026, 1027, 1028, 1029, 1433, 1720, 1723, 2000, 2001, 2049, 2103, 2107, 2121, 2717,
	49152, 49153, 49154, 49155, 49156, 49157, 5000, 5001, 5009, 5050, 5051, 5432, 554, 5601, 5631,
	5900, 6464, 6646, 8739, 8888, 10230, 15000, 16000, 30000,
}

var ALL_PORTS = []uint16{}

type ScanOptions struct {
	Address string
	Ports   string
}

type ScanResult struct {
	Total int      `json:"total"`
	Ports []uint16 `json:"ports"`
}

func ScanPorts(options ScanOptions) ScanResult {
	var ports []uint16
	if options.Ports == "full" {
		ports = getAllPorts()
	} else {
		ports = COMMON_PORTS
	}

	result := make(chan uint16)
	var wg sync.WaitGroup
	for _, port := range ports {
		wg.Add(1)
		go func(p uint16) {
			defer wg.Done()
			if scanPort(options.Address, p) {
				result <- p
			}
		}(port)
	}

	go func() {
		wg.Wait()
		close(result)
	}()

	openPorts := []uint16{}
	for port := range result {
		openPorts = append(openPorts, port)
	}

	return ScanResult{
		len(openPorts),
		openPorts,
	}
}

func scanPort(address string, port uint16) bool {
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", address, port), 2*time.Second)
	if err != nil {
		return false
	}
	defer conn.Close()

	return true
}

func getAllPorts() []uint16 {
	ports := make([]uint16, 65536)
	for i := 0; i < 65536; i++ {
		ports[i] = uint16(i)
	}
	return ports
}
